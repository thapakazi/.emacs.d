#+TITLE: Basic modes/configs rest here
#+DATE: Friday, Feb 26 2016
#+DESCRIPTION: default shared basic modes/configs goes here

* Default Scratch Pad
  #+begin_src emacs-lisp
  ;;(setq initial-major-mode 'js-mode)
  #+end_src

* [[https://www.emacswiki.org/emacs/AutoComplete][AutoComplete]]
  Auto complete whem you type with nice popup menu :D
  #+BEGIN_SRC emacs-lisp
(use-package auto-complete
  :ensure t
  :config
  (ac-config-default))

  #+END_SRC

  #+RESULTS:
  : t

* COMMENT fasd
  #+BEGIN_SRC emacs-lisp
;;;; fasd
;; find previous files/dirs quickly (uses `fasd' shell script)
(use-package fasd
  :bind ("C-h C-f" . fasd-find-file)
  :config
  (setq fasd-completing-read-function 'helm--completing-read-default)
  (global-fasd-mode 1))
  #+END_SRC

        
* [[http://batsov.com/projectile/][Projectile]]
  Working with multiple projects, and typing everything yourself to
  switch really sucks.. ü§ï

  #+BEGIN_QUOTE
  Project navigation and management library for Emacs.
  #+END_QUOTE

  #+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :commands projectile-mode
  :config
  (progn
    (projectile-global-mode t)
    (setq projectile-enable-caching t)
    (use-package ag
      :commands ag
      :ensure t)))
  #+end_src

  My personal favorites:
  #+BEGIN_EXAMPLE
  projectile-switch-project ; C-c p p
  projectile-find-file; C-c p f
  #+END_EXAMPLE

* Forcing Vertical Splits
#+begin_src emacs-lisp
(setq split-width-threshold 0)
(setq split-height-threshold nil)
#+end_src

* Multiple cursors
  yes, everyones fan of this video: [[http://emacsrocks.com/e13.html][on youtube]]

  #+BEGIN_SRC emacs-lisp
    (use-package multiple-cursors
      :ensure t
      :bind  (
	     ("C-S-c C-S-c" . mc/edit-lines)
	     ("C->" . mc/mark-next-like-this)
	     ("C-S-<mouse-5>" . mc/mark-next-like-this)
	     ("C-<" . mc/mark-previous-like-this)
	     ("C-S-<mouse-4>" . mc/mark-next-like-this)
	     ("C-c C-<" . mc/mark-all-like-this)
	     ("s-<mouse-1>" . mc/add-cursor-on-click)))
  #+END_SRC

  #+RESULTS:
  : mc/add-cursor-on-click


* [[https://github.com/abo-abo/hydra][Hydra]] [[https://www.youtube.com/watch?v=_qZliI1BKzI][youtube]]
  Tie up rellated commands into a family of short bindings wtih a
  common prefix; from [[https://github.com/abo-abo/hydra/blob/master/README.md][Readme.md]] ü§ñ
  
  #+BEGIN_SRC emacs-lisp
  (use-package hydra
  :ensure t
  :config
  (hydra-add-font-lock))
  #+END_SRC

  Some hydra in action. üòè
  #+BEGIN_SRC emacs-lisp
(require 'windmove)

(defun hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))

(defhydra hydra-splitter (global-map "<f9>")
  "splitter"
  ("<left>" hydra-move-splitter-left)
  ("<down>" hydra-move-splitter-down)
  ("<up>" hydra-move-splitter-up)
  ("<right>" hydra-move-splitter-right))
  #+END_SRC

  Yet another useful stuff
  #+BEGIN_SRC emacs-lisp
(defhydra hydra-zoom (global-map "<f5>")
  "zoom"
  ("g" text-scale-increase "in")
  ("l" text-scale-decrease "out"))
  #+END_SRC
  
* Modern Minibuffer Completion
  :PROPERTIES:
  :CUSTOM_ID: minibuffer-completion
  :END:

  The following packages provide a modern, modular minibuffer completion system.
  Each package does one thing well and composes with the others.

  Reference: [[https://protesilaos.com/codelog/2024-02-17-emacs-modern-minibuffer-packages/][Emacs: modern minibuffer packages (Prot)]]

** [[https://github.com/minad/vertico][Vertico]] - Vertical Completion UI
   Applies a vertical layout to the minibuffer and pops it up eagerly
   so we can see available options without further interactions.
   Fast and "just works", but also highly customisable.

   #+BEGIN_SRC emacs-lisp
(use-package vertico
  :ensure t
  :config
  (setq vertico-cycle t)
  (setq vertico-resize nil)
  (vertico-mode 1))

;; savehist-mode saves minibuffer histories.
;; Vertico uses this to put recently selected options at the top.
(savehist-mode 1)

;; recentf-mode keeps track of recently visited files.
;; Access through consult-buffer or consult-recent-file.
(recentf-mode 1)
   #+END_SRC

** [[https://github.com/oantolin/orderless][Orderless]] - Flexible Matching
   Lets the minibuffer use out-of-order pattern matching.
   Matches space-separated words or regexes in any order.
   e.g., "ins pac" matches ~package-menu-mark-install~ and ~package-install~.

   #+BEGIN_SRC emacs-lisp
(use-package orderless
  :ensure t
  :config
  (setq completion-styles '(orderless basic)))
   #+END_SRC

** [[https://github.com/minad/marginalia][Marginalia]] - Rich Annotations
   Provides helpful annotations next to completion candidates.
   Shows file permissions, modification dates, buffer sizes, docstrings, etc.

   #+BEGIN_SRC emacs-lisp
(use-package marginalia
  :ensure t
  :config
  (marginalia-mode 1))
   #+END_SRC

** [[https://github.com/minad/consult][Consult]] - Enhanced Commands
   Provides enhanced variants of built-in commands with live preview.
   Shows context of current match in another window as you navigate.

   #+BEGIN_SRC emacs-lisp
(use-package consult
  :ensure t
  :bind
  (("C-s" . consult-line)             ; search current buffer
   ("C-x b" . consult-buffer)         ; switch buffer/recent/bookmark
   ("M-g g" . consult-goto-line)
   ("M-g M-g" . consult-goto-line)
   ("M-g o" . consult-outline)        ; jump to outline headings
   ("M-s r" . consult-ripgrep)        ; recursive grep
   ("M-s f" . consult-find)           ; find files by name
   ("M-s l" . consult-line)
   ("M-s g" . consult-grep)))
   #+END_SRC

** [[https://github.com/oantolin/embark][Embark]] - Contextual Actions
   Target the thing at point and select an action to perform on it.
   In the minibuffer, ~embark-collect~ retains minibuffer behaviour,
   while ~embark-export~ places results in a specialised buffer
   (e.g., grep results ‚Üí grep-mode, files ‚Üí dired).

   #+BEGIN_SRC emacs-lisp
(use-package embark
  :ensure t
  :bind
  (("C-." . embark-act)               ; pick an action
   ("C-;" . embark-dwim)              ; do what I mean
   ("C-h B" . embark-bindings)        ; show all bindings
   :map minibuffer-local-map
   ("C-c C-c" . embark-collect)       ; collect to buffer (keeps minibuffer behavior)
   ("C-c C-e" . embark-export)))      ; export to appropriate mode (dired/grep-mode)

(use-package embark-consult
  :ensure t
  :after (embark consult))
   #+END_SRC

** [[https://github.com/mhayashi1120/Emacs-wgrep][Wgrep]] - Edit Grep Results
   Edit results of a grep search inside a ~grep-mode~ buffer.
   Toggle editable mode, make changes, then ~C-c C-c~ to confirm or ~C-c C-k~ to abort.
   Powerful combo: ~consult-ripgrep~ ‚Üí ~C-c C-e~ (embark-export) ‚Üí edit with wgrep.

   #+BEGIN_SRC emacs-lisp
(use-package wgrep
  :ensure t
  :bind
  (:map grep-mode-map
   ("e" . wgrep-change-to-wgrep-mode)
   ("C-x C-q" . wgrep-change-to-wgrep-mode)
   ("C-c C-c" . wgrep-finish-edit)))
   #+END_SRC

** Consult + Projectile Integration
   #+BEGIN_SRC emacs-lisp
(use-package consult-projectile
  :ensure t
  :after (consult projectile)
  :bind
  ("C-c p" . projectile-command-map))
   #+END_SRC
* Set default envs
  #+begin_src emacs-lisp
  (setenv "VISUAL" "emacsclient")
  (setenv "EDITOR" (getenv "VISUAL"))
  #+end_src

* Exec path from shell
#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :vc (:url "https://github.com/purcell/exec-path-from-shell")
  :config
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize))
  )
#+end_src
