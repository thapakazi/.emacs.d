#+TITLE: Emacs Configuration, with org txt: totally awesome ;)
#+AUTHOR: Daniel Mai
#+FORKER: Milan Thapa
#+DESCRIPTION: I customised the for puerly the arch way.

This configuration uses the [[https://github.com/jwiegley/use-package][use-package]] package from John Wiegley, which is a fantastic way to manage package configurations.

Sorry Mai, I have scrambled your configs for sake of mine :D
Since my days with breaking emacs continued since last year 2013, I tried so many options: *g:rhoit* *spacemacs*... long list, but still not satifsfied.. until this awesome youtube url happened. Then everythings changed

Now the changes below are upon [[https://github.com/danielmai/.emacs.d.git][Daniels's fork]]. He seems to be happy mac user :P. So I am customising the emacs the arch way for all emacso archians out there. PS: Maybe I would get sometime/someone do it for others too.

[[https://youtu.be/WZzcEJQ8Hnw?t=48][Enough talk let do it]]


* Installing Emacs

  If you are crazy about the latest-greatest release :like me, please collect it from aur/yaourt.
  #+BEGIN_SRC sh :results drawer
emacs --version
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  GNU Emacs 25.0.50.1
  Copyright (C) 2015 Free Software Foundation, Inc.
  GNU Emacs comes with ABSOLUTELY NO WARRANTY.
  You may redistribute copies of GNU Emacs
  under the terms of the GNU General Public License.
  For more information about these matters, see the file named COPYING.
  :END:

  #+begin_src sh
  echo "I prefer emacs installation from git :D, & I ain't mac user"
  #+end_src

* Personal Information
  #+begin_src emacs-lisp
(setq user-full-name "Milan Thapa"
      user-mail-address "oemilan@gmail.com")
  #+end_src

* Customize settings

 Set up the customize file to its own separate file, instead of saving
 customize settings in [[file:init.el][init.el]].

 #+begin_src emacs-lisp
 (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
 (load custom-file)
 #+end_src

* Theme
** Cyberpunk theme

   The [[https://github.com/n3mo/cyberpunk-theme.el][cyberpunk theme]] is dark and colorful. However, I don't like the
   boxes around the mode line.

   #+begin_src emacs-lisp
  (use-package cyberpunk-theme
    :ensure t
    :init
    (progn
      (load-theme 'cyberpunk t)
      (set-face-attribute `mode-line nil
                          :box nil)
      (set-face-attribute `mode-line-inactive nil
                          :box nil)))
   #+end_src

   I tend to switch themes more often than normal. For example, switching
   to a lighter theme (such as the default) or to a different theme
   depending on the time of day or my mood. Normally, switching themes is
   a multi-step process with ~disable-theme~ and ~load-theme~. The
   ~switch-theme~ function will do that in one swoop. I just choose which
   theme I want to go to.

** Solarized theme

   Here's some configuration for [[https://github.com/bbatsov/solarized-emacs/][bbatsov's solarized themes]].

   #+begin_src emacs-lisp
(use-package solarized-theme
  :ensure t
  :init
  (;; Don't change the font for some headings and titles
   setq solarized-use-variable-pitch nil)
  )
   #+end_src
** Monokai theme

   #+begin_src emacs-lisp
(setq monokai-use-variable-pitch nil)
   #+end_src

** Convenient theme functions

   #+begin_src emacs-lisp
   (defun switch-theme (theme)
  "Disables any currently active themes and loads THEME."
  ;; This interactive call is taken from `load-theme'
  (interactive
   (list
    (intern (completing-read "Load custom theme: "
                             (mapc 'symbol-name
                                   (custom-available-themes))))))
                                   (let ((enabled-themes custom-enabled-themes))
                                   (mapc #'disable-theme custom-enabled-themes)
                                   (load-theme theme t)))

    (defun disable-active-themes ()
    "Disables any currently active themes listed in `custom-enabled-themes'."
    (interactive)
    (mapc #'disable-theme custom-enabled-themes))

    (bind-key "s-<f12>" 'switch-theme)
    (bind-key "s-<f11>" 'disable-active-themes)
   #+end_src

* Font

  [[http://levien.com/type/myfonts/inconsolata.html][Inconsolata]] is a nice monospaced font.

  Pull it with pacman. 
  #+begin_src sh :tangle no :results drawer
yes 'y' | sudo pacman -S ttf-inconsolata
  #+end_src

  #+RESULTS:
  :RESULTS:
  resolving dependencies...
  looking for conflicting packages...

  Packages (1) ttf-inconsolata-20090215-5

  Total Installed Size:  0.10 MiB
  Net Upgrade Size:      0.00 MiB

  checking keyring...
  checking package integrity...
  loading package files...
  checking for file conflicts...
  checking available disk space...
  reinstalling ttf-inconsolata...
  Updating font cache... done.
  :END:

  And here's how we tell Emacs to use the font we want to use.

  #+begin_src emacs-lisp
(add-to-list 'default-frame-alist
             '(font . "Inconsolata-20"))
  #+end_src

* Sane defaults

  Let's start with some sane defaults, shall we?

  Sources for this section include [[https://github.com/magnars/.emacs.d/blob/master/settings/sane-defaults.el][Magnars Sveen]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua]].
  #+begin_src emacs-lisp
    ;; These functions are useful. Activate them.
    (put 'downcase-region 'disabled nil)
    (put 'upcase-region 'disabled nil)
    (put 'narrow-to-region 'disabled nil)
    (put 'dired-find-alternate-file 'disabled nil)

    ;; Answering just 'y' or 'n' will do
    (defalias 'yes-or-no-p 'y-or-n-p)

    ;; Keep all backup and auto-save files in one directory
    (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
    (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

    ;; UTF-8 please
    (setq locale-coding-system 'utf-8) ; pretty
    (set-terminal-coding-system 'utf-8) ; pretty
    (set-keyboard-coding-system 'utf-8) ; pretty
    (set-selection-coding-system 'utf-8) ; please
    (prefer-coding-system 'utf-8) ; with sugar on top
    (setq-default indent-tabs-mode nil)

    ;; Turn off the blinking cursor
    (blink-cursor-mode -1)

     (setq-default indent-tabs-mode nil)
     (setq-default indicate-empty-lines t)

     ;; Don't count two spaces after a period as the end of a sentence.
     ;; Just one space is needed.
     (setq sentence-end-double-space nil)

     ;; delete the region when typing, just like as we expect nowadays.
     (delete-selection-mode t)

     (show-paren-mode t)

     (column-number-mode t)

     (global-visual-line-mode)
     (diminish 'visual-line-mode)

     (setq uniquify-buffer-name-style 'forward)
     ;; -i gets alias definitions from .bash_profile
     (setq shell-command-switch "-ic")

     ;; Don't beep at me
     (setq visible-bell t)
 #+end_src

 The following function for ~occur-dwim~ is taken from [[https://github.com/abo-abo][Oleh Krehel]] from
 [[http://oremacs.com/2015/01/26/occur-dwim/][his blog post at (or emacs]]. It takes the current region or the symbol
 at point as the default value for occur.

 #+begin_src emacs-lisp
 (defun occur-dwim ()
   "Call `occur' with a sane default."
   (interactive)
   (push (if (region-active-p)
             (buffer-substring-no-properties
             (region-beginning)
              (region-end))
           (thing-at-point 'symbol))
         regexp-history)
   (call-interactively 'occur))

 (bind-key "M-s o" 'occur-dwim)
 #+end_src

* List buffers

 ibuffer is the improved version of list-buffers.

 #+begin_src emacs-lisp
 ;; make ibuffer the default buffer lister.
 (defalias 'list-buffers 'ibuffer)
 #+end_src

 source: http://ergoemacs.org/emacs/emacs_buffer_management.html

 #+begin_src emacs-lisp
 (add-hook 'dired-mode-hook 'auto-revert-mode)

 ;; Also auto refresh dired, but be quiet about it
 (setq global-auto-revert-non-file-buffers t)
 (setq auto-revert-verbose nil)
 #+end_src

 source: [[http://whattheemacsd.com/sane-defaults.el-01.html][Magnars Sveen]]

* Recentf

 #+begin_src emacs-lisp
 (use-package recentf
   :commands ido-recentf-open
   :init
   (progn
     (recentf-mode t)
     (setq recentf-max-saved-items 200)

     (defun ido-recentf-open ()
       "Use `ido-completing-read' to \\[find-file] a recent file"
       (interactive)
       (if (find-file (ido-completing-read "Find recent file: " recentf-list))
           (message "Opening file...")
         (message "Aborting")))

     (bind-key "C-x r" 'ido-recentf-open)))
 #+end_src

* Org mode

  Truly the way to [[http://orgmode.org/][live life in plain text]]. I mainly use it to take
  notes and save executable source blocks. I'm also starting to make use
  of its agenda, timestamping, and capturing features.

  It goes without saying that I also use it to manage my Emacs config.

** Org activation bindings

  Set up some global key bindings that integrate with Org Mode features.

 #+begin_src emacs-lisp
 (bind-key "C-c l" 'org-store-link)
 (bind-key "C-c c" 'org-capture)
 (bind-key "C-c a" 'org-agenda)
 #+end_src

*** Org agenda

 Learned about [[https://github.com/sachac/.emacs.d/blob/83d21e473368adb1f63e582a6595450fcd0e787c/Sacha.org#org-agenda][this =delq= and =mapcar= trick from Sacha Chua's config]].

 #+begin_src emacs-lisp
 (setq org-agenda-files
       (delq nil
             (mapcar (lambda (x) (and (file-exists-p x) x))
                     '("~/Dropbox/Agenda"))))
 #+end_src

 *** Org capture

 #+begin_src emacs-lisp
 (bind-key "C-c c" 'org-capture)
 (setq org-default-notes-file "~/Dropbox/Notes/notes.org")
 #+end_src

** Org setup

 Speed commands are a nice and quick way to perform certain actions
 while at the beginning of a heading. It's not activated by default.

 See the doc for speed keys by checking out [[elisp:(info%20"(org)%20speed%20keys")][the documentation for  speed keys in Org mode]].

 #+begin_src emacs-lisp
 (setq org-use-speed-commands t)
 #+end_src

 #+begin_src emacs-lisp
 (setq org-image-actual-width 550)
 #+end_src
** Org tags

 The default value is -77, which is weird for smaller width windows.
 I'd rather have the tags align horizontally with the header. 45 is a
 good column number to do that.

 #+begin_src emacs-lisp
 (setq org-tags-column 45)
 #+end_src

** Org babel languages

  #+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
     (C . t)
     (calc . t)
     (latex . t)
     (java . t)
     (ruby . t)
     (scheme . t)
     (sh . t)
     (sqlite . t)
     (js . t)))

  (defun my-org-confirm-babel-evaluate (lang body)
    "Do not confirm evaluation for these languages."
    (not (or (string= lang "C")
             (string= lang "java")
             (string= lang "python")
             (string= lang "emacs-lisp")
             (string= lang "sqlite"))))
  (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
  #+end_src

** Org babel/source blocks

  I like to have source blocks properly syntax highlighted and with the
  editing popup window staying within the same window so all the windows
  don't jump around. Also, having the top and bottom trailing lines in
  the block is a waste of space, so we can remove them.

  I noticed that fontification doesn't work with markdown mode when the
  block is indented after editing it in the org src buffer---the leading
  #s for headers don't get fontified properly because they appear as Org
  comments. Setting ~org-src-preserve-indentation~ makes things
  consistent as it doesn't pad source blocks with leading spaces.

  #+begin_src emacs-lisp
  (setq org-src-fontify-natively t
        org-src-window-setup 'current-window
        org-src-strip-leading-and-trailing-blank-lines t
        org-src-preserve-indentation t
        org-src-tab-acts-natively t)
  #+end_src
** Org exporting

*** Pandoc exporter

 Pandoc converts between a huge number of different file formats. 

 #+begin_src emacs-lisp
 (use-package ox-pandoc
   :no-require t
   :ensure t)
 #+end_src

** Org yasnipets
   Simple handy org snippets pulled from all of awesome people.
   #+BEGIN_SRC emacs-lisp

   #+END_SRC

** Org mouse                                 :fixme:
   Better mouse support for org-mode: [[http://orgmode.org/w/?p=org-mode.git;a=blob_plain;f=lisp/org-mouse.el;hb=HEAD][org-mouse]]
   #+BEGIN_SRC emacs-lisp
   ;;; org-mouse.el --- Better mouse support for org-mode

;; Copyright (C) 2006-2016 Free Software Foundation, Inc.

;; Author: Piotr Zielinski <piotr dot zielinski at gmail dot com>
;; Maintainer: Carsten Dominik <carsten at orgmode dot org>

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Org-mouse provides mouse support for org-mode.
;;
;; http://orgmode.org
;;
;; Org-mouse implements the following features:
;; * following links with the left mouse button (in Emacs 22)
;; * subtree expansion/collapse (org-cycle) with the left mouse button
;; * several context menus on the right mouse button:
;;    + general text
;;    + headlines
;;    + timestamps
;;    + priorities
;;    + links
;;    + tags
;; * promoting/demoting/moving subtrees with mouse-3
;;    + if the drag starts and ends in the same line then promote/demote
;;    + otherwise move the subtree
;;
;; Use
;; ---
;;
;; To use this package, put the following line in your .emacs:
;;
;;    (require 'org-mouse)
;;

;; FIXME:
;; + deal with folding / unfolding issues

;; TODO (This list is only theoretical, if you'd like to have some
;; feature implemented or a bug fix please send me an email, even if
;; something similar appears in the list below.  This will help me get
;; the priorities right.):
;;
;; + org-store-link, insert link
;; + org tables
;; + occur with the current word/tag (same menu item)
;; + ctrl-c ctrl-c, for example, renumber the current list
;; + internal links

;; Please email the maintainer with new feature suggestions / bugs

;; History:
;;
;; Since version 5.10: Changes are listed in the general org-mode docs.
;;
;; Version 5.09;; + Version number synchronization with Org-mode.
;;
;; Version 0.25
;; + made compatible with org-mode 4.70 (thanks to Carsten for the patch)
;;
;; Version 0.24
;; + minor changes to the table menu
;;
;; Version 0.23
;; + preliminary support for tables and calculation marks
;; + context menu support for org-agenda-undo & org-sort-entries
;;
;; Version 0.22
;; + handles undo support for the agenda buffer (requires org-mode >=4.58)
;;
;; Version 0.21
;; + selected text activates its context menu
;; + shift-middleclick or right-drag inserts the text from the clipboard in the form of a link
;;
;; Version 0.20
;; + the new "TODO Status" submenu replaces the "Cycle TODO" menu item
;; + the TODO menu can now list occurrences of a specific TODO keyword
;; + #+STARTUP line is now recognized
;;
;; Version 0.19
;; + added support for dragging URLs to the org-buffer
;;
;; Version 0.18
;; + added support for agenda blocks
;;
;; Version 0.17
;; + toggle checkboxes with a single click
;;
;; Version 0.16
;; + added support for checkboxes
;;
;; Version 0.15
;; + org-mode now works with the Agenda buffer as well
;;
;; Version 0.14
;; + added a menu option that converts plain list items to outline items
;;
;; Version 0.13
;; + "Insert Heading" now inserts a sibling heading if the point is
;;   on "***" and a child heading otherwise
;;
;; Version 0.12
;; + compatible with Emacs 21
;; + custom agenda commands added to the main menu
;; + moving trees should now work between windows in the same frame
;;
;; Version 0.11
;; + fixed org-mouse-at-link (thanks to Carsten)
;; + removed [follow-link] bindings
;;
;; Version 0.10
;; + added a menu option to remove highlights
;; + compatible with org-mode 4.21 now
;;
;; Version 0.08:
;; + trees can be moved/promoted/demoted by dragging with the right
;;   mouse button (mouse-3)
;; + small changes in the above function
;;
;; Versions 0.01 -- 0.07: (I don't remember)

;;; Code:

(eval-when-compile (require 'cl))
(require 'org)

(defvar org-agenda-allow-remote-undo)
(defvar org-agenda-undo-list)
(defvar org-agenda-custom-commands)
(declare-function org-agenda-change-all-lines "org-agenda"
		  (newhead hdmarker &optional fixface just-this))
(declare-function org-verify-change-for-undo "org-agenda" (l1 l2))
(declare-function org-apply-on-list "org-list" (function init-value &rest args))
(declare-function org-agenda-earlier "org-agenda" (arg))
(declare-function org-agenda-later "org-agenda" (arg))

(defvar org-mouse-plain-list-regexp "\\([ \t]*\\)\\([-+*]\\|[0-9]+[.)]\\) "
  "Regular expression that matches a plain list.")
(defvar org-mouse-direct t
  "Internal variable indicating whether the current action is direct.

If t, then the current action has been invoked directly through the buffer
it is intended to operate on.  If nil, then the action has been invoked
indirectly, for example, through the agenda buffer.")

(defgroup org-mouse nil
  "Mouse support for org-mode."
  :tag "Org Mouse"
  :group 'org)

(defcustom org-mouse-punctuation ":"
  "Punctuation used when inserting text by drag and drop."
  :group 'org-mouse
  :type 'string)

(defcustom org-mouse-features
  '(context-menu yank-link activate-stars activate-bullets activate-checkboxes)
  "The features of org-mouse that should be activated.
Changing this variable requires a restart of Emacs to get activated."
  :group 'org-mouse
  :type '(set :greedy t
	      (const :tag "Mouse-3 shows context menu" context-menu)
	      (const :tag "C-mouse-1 and mouse-3 move trees" move-tree)
	      (const :tag "S-mouse-2 and drag-mouse-3 yank link" yank-link)
	      (const :tag "Activate headline stars" activate-stars)
	      (const :tag "Activate item bullets" activate-bullets)
	      (const :tag "Activate checkboxes" activate-checkboxes)))

(defun org-mouse-re-search-line (regexp)
  "Search the current line for a given regular expression."
  (beginning-of-line)
  (re-search-forward regexp (point-at-eol) t))

(defun org-mouse-end-headline ()
  "Go to the end of current headline (ignoring tags)."
  (interactive)
  (end-of-line)
  (skip-chars-backward "\t ")
  (when (org-looking-back ":[A-Za-z]+:" (line-beginning-position))
    (skip-chars-backward ":A-Za-z")
    (skip-chars-backward "\t ")))

(defvar-local org-mouse-context-menu-function nil
  "Function to create the context menu.
The value of this variable is the function invoked by
`org-mouse-context-menu' as the context menu.")

(defun org-mouse-show-context-menu (event prefix)
  "Invoke the context menu.

If the value of `org-mouse-context-menu-function' is a function, then
this function is called.  Otherwise, the current major mode menu is used."
  (interactive "@e \nP")
  (if (and (= (event-click-count event) 1)
	   (or (not mark-active)
	       (sit-for (/ double-click-time 1000.0))))
      (progn
	(select-window (posn-window (event-start event)))
	(when (not (org-mouse-mark-active))
	  (goto-char (posn-point (event-start event)))
	  (when (not (eolp)) (save-excursion (run-hooks 'post-command-hook)))
	  (sit-for 0))
	(if (functionp org-mouse-context-menu-function)
	    (funcall org-mouse-context-menu-function event)
	  (if (fboundp 'mouse-menu-major-mode-map)
	      (popup-menu (mouse-menu-major-mode-map) event prefix)
	    (org-no-warnings ; don't warn about fallback, obsolete since 23.1
	     (mouse-major-mode-menu event prefix)))))
    (setq this-command 'mouse-save-then-kill)
    (mouse-save-then-kill event)))

(defun org-mouse-line-position ()
  "Return `:beginning' or `:middle' or `:end', depending on the point position.

If the point is at the end of the line, return `:end'.
If the point is separated from the beginning of the line only by white
space and *'s (`org-mouse-bolp'), return `:beginning'.  Otherwise,
return `:middle'."
  (cond
   ((eolp) :end)
   ((org-mouse-bolp) :beginning)
   (t :middle)))

(defun org-mouse-empty-line ()
  "Return non-nil iff the line contains only white space."
  (save-excursion (beginning-of-line) (looking-at "[ \t]*$")))

(defun org-mouse-next-heading ()
  "Go to the next heading.
If there is none, ensure that the point is at the beginning of an empty line."
  (unless (outline-next-heading)
    (beginning-of-line)
    (unless (org-mouse-empty-line)
      (end-of-line)
      (newline))))

(defun org-mouse-insert-heading ()
  "Insert a new heading, as `org-insert-heading'.

If the point is at the :beginning (`org-mouse-line-position') of the line,
insert the new heading before the current line.  Otherwise, insert it
after the current heading."
  (interactive)
  (case (org-mouse-line-position)
    (:beginning (beginning-of-line)
		(org-insert-heading))
    (t (org-mouse-next-heading)
       (org-insert-heading))))

(defun org-mouse-timestamp-today (&optional shift units)
  "Change the timestamp into SHIFT UNITS in the future.

For the acceptable UNITS, see `org-timestamp-change'."
  (interactive)
  (org-time-stamp nil)
  (when shift (org-timestamp-change shift units)))

(defun org-mouse-keyword-menu (keywords function &optional selected itemformat)
  "A helper function.

Returns a menu fragment consisting of KEYWORDS.  When a keyword
is selected by the user, FUNCTION is called with the selected
keyword as the only argument.

If SELECTED is nil, then all items are normal menu items.  If
SELECTED is a function, then each item is a checkbox, which is
enabled for a given keyword iff (funcall SELECTED keyword) return
non-nil.  If SELECTED is neither nil nor a function, then the
items are radio buttons.  A radio button is enabled for the
keyword `equal' to SELECTED.

ITEMFORMAT governs formatting of the elements of KEYWORDS.  If it
is a function, it is invoked with the keyword as the only
argument.  If it is a string, it is interpreted as the format
string to (format ITEMFORMAT keyword).  If it is neither a string
nor a function, elements of KEYWORDS are used directly."
  (mapcar
   `(lambda (keyword)
      (vector (cond
	       ((functionp ,itemformat) (funcall ,itemformat keyword))
	       ((stringp ,itemformat) (format ,itemformat keyword))
	       (t keyword))
	      (list 'funcall ,function keyword)
	      :style (cond
		      ((null ,selected) t)
		      ((functionp ,selected) 'toggle)
		      (t 'radio))
	      :selected (if (functionp ,selected)
			    (and (funcall ,selected keyword) t)
			  (equal ,selected keyword))))
   keywords))

(defun org-mouse-remove-match-and-spaces ()
  "Remove the match, make just one space around the point."
  (interactive)
  (replace-match "")
  (just-one-space))

(defvar org-mouse-rest)
(defun org-mouse-replace-match-and-surround (newtext &optional fixedcase
						     literal string subexp)
  "The same as `replace-match', but surrounds the replacement with spaces."
  (apply 'replace-match org-mouse-rest)
  (save-excursion
    (goto-char (match-beginning (or subexp 0)))
    (just-one-space)
    (goto-char (match-end (or subexp 0)))
    (just-one-space)))

(defun org-mouse-keyword-replace-menu (keywords &optional group itemformat
						nosurround)
  "A helper function.

Returns a menu fragment consisting of KEYWORDS.  When a keyword
is selected, group GROUP of the current match is replaced by the
keyword.  The method ensures that both ends of the replacement
are separated from the rest of the text in the buffer by
individual spaces (unless NOSURROUND is non-nil).

The final entry of the menu is always \"None\", which removes the
match.

ITEMFORMAT governs formatting of the elements of KEYWORDS.  If it
is a function, it is invoked with the keyword as the only
argument.  If it is a string, it is interpreted as the format
string to (format ITEMFORMAT keyword).  If it is neither a string
nor a function, elements of KEYWORDS are used directly."
  (setq group (or group 0))
  (let ((replace (org-mouse-match-closure
		  (if nosurround 'replace-match
		    'org-mouse-replace-match-and-surround))))
    (append
     (org-mouse-keyword-menu
      keywords
      `(lambda (keyword) (funcall ,replace keyword t t nil ,group))
      (match-string group)
      itemformat)
     `(["None" org-mouse-remove-match-and-spaces
	:style radio
	:selected ,(not (member (match-string group) keywords))]))))

(defun org-mouse-show-headlines ()
  "Change the visibility of the current org buffer to only show headlines."
  (interactive)
  (let ((this-command 'org-cycle)
	(last-command 'org-cycle)
	(org-cycle-global-status nil))
    (org-cycle '(4))
    (org-cycle '(4))))

(defun org-mouse-show-overview ()
  "Change visibility of current org buffer to first-level headlines only."
  (interactive)
  (let ((org-cycle-global-status nil))
    (org-cycle '(4))))

(defun org-mouse-set-priority (priority)
  "Set the priority of the current headline to PRIORITY."
  (org-priority priority))

(defvar org-mouse-priority-regexp "\\[#\\([A-Z]\\)\\]"
  "Regular expression matching the priority indicator.
Differs from `org-priority-regexp' in that it doesn't contain the
leading `.*?'.")

(defun org-mouse-get-priority (&optional default)
  "Return the priority of the current headline.
DEFAULT is returned if no priority is given in the headline."
  (save-excursion
    (if (org-mouse-re-search-line org-mouse-priority-regexp)
	(match-string 1)
      (when default (char-to-string org-default-priority)))))

(defun org-mouse-delete-timestamp ()
  "Deletes the current timestamp as well as the preceding keyword.
SCHEDULED: or DEADLINE: or ANYTHINGLIKETHIS:"
  (when (or (org-at-date-range-p) (org-at-timestamp-p))
    (replace-match "")			; delete the timestamp
    (skip-chars-backward " :A-Z")
    (when (looking-at " *[A-Z][A-Z]+:")
      (replace-match ""))))

(defun org-mouse-looking-at (regexp skipchars &optional movechars)
  (save-excursion
    (let ((point (point)))
      (if (looking-at regexp) t
	(skip-chars-backward skipchars)
	(forward-char (or movechars 0))
	(when (looking-at regexp)
	  (> (match-end 0) point))))))

(defun org-mouse-priority-list ()
  (loop for priority from ?A to org-lowest-priority
	collect (char-to-string priority)))

(defun org-mouse-todo-menu (state)
  "Create the menu with TODO keywords."
  (append
   (let ((kwds org-todo-keywords-1))
     (org-mouse-keyword-menu
      kwds
      `(lambda (kwd) (org-todo kwd))
      (lambda (kwd) (equal state kwd))))))

(defun org-mouse-tag-menu ()		;todo
  "Create the tags menu."
  (append
   (let ((tags (org-get-tags)))
     (org-mouse-keyword-menu
      (sort (mapcar 'car (org-get-buffer-tags)) 'string-lessp)
      `(lambda (tag)
	 (org-mouse-set-tags
	  (sort (if (member tag (quote ,tags))
		    (delete tag (quote ,tags))
		  (cons tag (quote ,tags)))
		'string-lessp)))
      `(lambda (tag) (member tag (quote ,tags)))
      ))
   '("--"
     ["Align Tags Here" (org-set-tags nil t) t]
     ["Align Tags in Buffer" (org-set-tags t t) t]
     ["Set Tags ..." (org-set-tags) t])))

(defun org-mouse-set-tags (tags)
  (save-excursion
    ;; remove existing tags first
    (beginning-of-line)
    (when (org-mouse-re-search-line ":\\(\\([A-Za-z_]+:\\)+\\)")
      (replace-match ""))

    ;; set new tags if any
    (when tags
      (end-of-line)
      (insert " :" (mapconcat 'identity tags ":") ":")
      (org-set-tags nil t))))

(defun org-mouse-insert-checkbox ()
  (interactive)
  (and (org-at-item-p)
       (goto-char (match-end 0))
       (unless (org-at-item-checkbox-p)
	 (delete-horizontal-space)
	 (insert " [ ] "))))

(defun org-mouse-agenda-type (type)
  (case type
    ('tags "Tags: ")
    ('todo "TODO: ")
    ('tags-tree "Tags tree: ")
    ('todo-tree "TODO tree: ")
    ('occur-tree "Occur tree: ")
    (t "Agenda command ???")))

(defun org-mouse-list-options-menu (alloptions &optional function)
  (let ((options (save-match-data
		   (split-string (match-string-no-properties 1)))))
    (print options)
    (loop for name in alloptions
	  collect
	  (vector name
		  `(progn
		     (replace-match
		      (mapconcat 'identity
				 (sort (if (member ',name ',options)
					   (delete ',name ',options)
					 (cons ',name ',options))
				       'string-lessp)
				 " ")
		      nil nil nil 1)
		     (when (functionp ',function) (funcall ',function)))
		  :style 'toggle
		  :selected (and (member name options) t)))))

(defun org-mouse-clip-text (text maxlength)
  (if (> (length text) maxlength)
      (concat (substring text 0 (- maxlength 3)) "...")
    text))

(defun org-mouse-popup-global-menu ()
  (popup-menu
   `("Main Menu"
     ["Show Overview" org-mouse-show-overview t]
     ["Show Headlines" org-mouse-show-headlines t]
     ["Show All" outline-show-all t]
     ["Remove Highlights" org-remove-occur-highlights
      :visible org-occur-highlights]
     "--"
     ["Check Deadlines"
      (if (functionp 'org-check-deadlines-and-todos)
	  (org-check-deadlines-and-todos org-deadline-warning-days)
	(org-check-deadlines org-deadline-warning-days)) t]
     ["Check TODOs" org-show-todo-tree t]
     ("Check Tags"
      ,@(org-mouse-keyword-menu
	 (sort (mapcar 'car (org-get-buffer-tags)) 'string-lessp)
	 #'(lambda (tag) (org-tags-sparse-tree nil tag)))
      "--"
      ["Custom Tag ..." org-tags-sparse-tree t])
     ["Check Phrase ..." org-occur]
     "--"
     ["Display Agenda" org-agenda-list t]
     ["Display Timeline" org-timeline t]
     ["Display TODO List" org-todo-list t]
     ("Display Tags"
      ,@(org-mouse-keyword-menu
	 (sort (mapcar 'car (org-get-buffer-tags)) 'string-lessp)
	 #'(lambda (tag) (org-tags-view nil tag)))
      "--"
      ["Custom Tag ..." org-tags-view t])
     ["Display Calendar" org-goto-calendar t]
     "--"
     ,@(org-mouse-keyword-menu
	(mapcar 'car org-agenda-custom-commands)
	#'(lambda (key)
	    (eval `(org-agenda nil (string-to-char ,key))))
	nil
	#'(lambda (key)
	    (let ((entry (assoc key org-agenda-custom-commands)))
	      (org-mouse-clip-text
	       (cond
		((stringp (nth 1 entry)) (nth 1 entry))
		((stringp (nth 2 entry))
		 (concat (org-mouse-agenda-type (nth 1 entry))
			 (nth 2 entry)))
		(t "Agenda Command `%s'"))
	       30))))
     "--"
     ["Delete Blank Lines" delete-blank-lines
      :visible (org-mouse-empty-line)]
     ["Insert Checkbox" org-mouse-insert-checkbox
      :visible (and (org-at-item-p) (not (org-at-item-checkbox-p)))]
     ["Insert Checkboxes"
      (org-mouse-for-each-item 'org-mouse-insert-checkbox)
      :visible (and (org-at-item-p) (not (org-at-item-checkbox-p)))]
     ["Plain List to Outline" org-mouse-transform-to-outline
      :visible (org-at-item-p)])))

(defun org-mouse-get-context (contextlist context)
  (let ((contextdata (assq context contextlist)))
    (when contextdata
      (save-excursion
	(goto-char (second contextdata))
	(re-search-forward ".*" (third contextdata))))))

(defun org-mouse-for-each-item (funct)
  ;; Functions called by `org-apply-on-list' need an argument
  (let ((wrap-fun (lambda (c) (funcall funct))))
    (when (ignore-errors (goto-char (org-in-item-p)))
      (save-excursion (org-apply-on-list wrap-fun nil)))))

(defun org-mouse-bolp ()
  "Return true if there only spaces, tabs, and `*' before point.
This means, between the beginning of line and the point."
  (save-excursion
    (skip-chars-backward " \t*") (bolp)))

(defun org-mouse-insert-item (text)
  (case (org-mouse-line-position)
    (:beginning			; insert before
     (beginning-of-line)
     (looking-at "[ \t]*")
     (open-line 1)
     (org-indent-to-column (- (match-end 0) (match-beginning 0)))
     (insert "+ "))
    (:middle			; insert after
     (end-of-line)
     (newline t)
     (indent-relative)
     (insert "+ "))
    (:end				; insert text here
     (skip-chars-backward " \t")
     (kill-region (point) (point-at-eol))
     (unless (org-looking-back org-mouse-punctuation (line-beginning-position))
       (insert (concat org-mouse-punctuation " ")))))
  (insert text)
  (beginning-of-line))

(defadvice dnd-insert-text (around org-mouse-dnd-insert-text activate)
  (if (derived-mode-p 'org-mode)
      (org-mouse-insert-item text)
    ad-do-it))

(defadvice dnd-open-file (around org-mouse-dnd-open-file activate)
  (if (derived-mode-p 'org-mode)
      (org-mouse-insert-item uri)
    ad-do-it))

(defun org-mouse-match-closure (function)
  (let ((match (match-data t)))
    `(lambda (&rest rest)
       (save-match-data
	 (set-match-data ',match)
	 (apply ',function rest)))))

(defun org-mouse-yank-link (click)
  (interactive "e")
  ;; Give temporary modes such as isearch a chance to turn off.
  (run-hooks 'mouse-leave-buffer-hook)
  (mouse-set-point click)
  (setq mouse-selection-click-count 0)
  (delete-horizontal-space)
  (insert-for-yank (concat " [[" (current-kill 0) "]] ")))

(defun org-mouse-context-menu (&optional event)
  (let* ((stamp-prefixes (list org-deadline-string org-scheduled-string))
	 (contextlist (org-context))
	 (get-context (lambda (context) (org-mouse-get-context contextlist context))))
    (cond
     ((org-mouse-mark-active)
      (let ((region-string (buffer-substring (region-beginning) (region-end))))
	(popup-menu
	 `(nil
	   ["Sparse Tree" (org-occur ',region-string)]
	   ["Find in Buffer" (occur ',region-string)]
	   ["Grep in Current Dir"
	    (grep (format "grep -rnH -e '%s' *" ',region-string))]
	   ["Grep in Parent Dir"
	    (grep (format "grep -rnH -e '%s' ../*" ',region-string))]
	   "--"
	   ["Convert to Link"
	    (progn (save-excursion (goto-char (region-beginning)) (insert "[["))
		   (save-excursion (goto-char (region-end)) (insert "]]")))]
	   ["Insert Link Here" (org-mouse-yank-link ',event)]))))
     ((save-excursion (beginning-of-line) (looking-at "[ \t]*#\\+STARTUP: \\(.*\\)"))
      (popup-menu
       `(nil
	 ,@(org-mouse-list-options-menu (mapcar 'car org-startup-options)
					'org-mode-restart))))
     ((or (eolp)
	  (and (looking-at "\\(  \\|\t\\)\\(+:[0-9a-zA-Z_:]+\\)?\\(  \\|\t\\)+$")
	       (org-looking-back "  \\|\t" (- (point) 2)
				 (line-beginning-position))))
      (org-mouse-popup-global-menu))
     ((funcall get-context :checkbox)
      (popup-menu
       '(nil
	 ["Toggle" org-toggle-checkbox t]
	 ["Remove" org-mouse-remove-match-and-spaces t]
	 ""
	 ["All Clear" (org-mouse-for-each-item
		       (lambda ()
			 (when (save-excursion (org-at-item-checkbox-p))
			   (replace-match "[ ] "))))]
	 ["All Set" (org-mouse-for-each-item
		     (lambda ()
		       (when (save-excursion (org-at-item-checkbox-p))
			 (replace-match "[X] "))))]
	 ["All Toggle" (org-mouse-for-each-item 'org-toggle-checkbox) t]
	 ["All Remove" (org-mouse-for-each-item
			(lambda ()
			  (when (save-excursion (org-at-item-checkbox-p))
			    (org-mouse-remove-match-and-spaces))))]
	 )))
     ((and (org-mouse-looking-at "\\b\\w+" "a-zA-Z0-9_")
	   (member (match-string 0) org-todo-keywords-1))
      (popup-menu
       `(nil
	 ,@(org-mouse-todo-menu (match-string 0))
	 "--"
	 ["Check TODOs" org-show-todo-tree t]
	 ["List all TODO keywords" org-todo-list t]
	 [,(format "List only %s" (match-string 0))
	  (org-todo-list (match-string 0)) t]
	 )))
     ((and (org-mouse-looking-at "\\b[A-Z]+:" "A-Z")
	   (member (match-string 0) stamp-prefixes))
      (popup-menu
       `(nil
	 ,@(org-mouse-keyword-replace-menu stamp-prefixes)
	 "--"
	 ["Check Deadlines" org-check-deadlines t]
	 )))
     ((org-mouse-looking-at org-mouse-priority-regexp "[]A-Z#") ; priority
      (popup-menu `(nil ,@(org-mouse-keyword-replace-menu
			   (org-mouse-priority-list) 1 "Priority %s" t))))
     ((funcall get-context :link)
      (popup-menu
       '(nil
	 ["Open" org-open-at-point t]
	 ["Open in Emacs" (org-open-at-point t) t]
	 "--"
	 ["Copy link" (org-kill-new (match-string 0))]
	 ["Cut link"
	  (progn
	    (kill-region (match-beginning 0) (match-end 0))
	    (just-one-space))]
	 "--"
	 ["Grep for TODOs"
	  (grep (format "grep -nH -i 'todo\\|fixme' %s*" (match-string 2)))]
					;       ["Paste file link" ((insert "file:") (yank))]
	 )))
     ((org-mouse-looking-at ":\\([A-Za-z0-9_]+\\):" "A-Za-z0-9_" -1) ;tags
      (popup-menu
       `(nil
	 [,(format-message "Display `%s'" (match-string 1))
	  (org-tags-view nil ,(match-string 1))]
	 [,(format-message "Sparse Tree `%s'" (match-string 1))
	  (org-tags-sparse-tree nil ,(match-string 1))]
	 "--"
	 ,@(org-mouse-tag-menu))))
     ((org-at-timestamp-p)
      (popup-menu
       '(nil
	 ["Show Day" org-open-at-point t]
	 ["Change Timestamp" org-time-stamp t]
	 ["Delete Timestamp" (org-mouse-delete-timestamp) t]
	 ["Compute Time Range" org-evaluate-time-range (org-at-date-range-p)]
	 "--"
	 ["Set for Today" org-mouse-timestamp-today]
	 ["Set for Tomorrow" (org-mouse-timestamp-today 1 'day)]
	 ["Set in 1 Week" (org-mouse-timestamp-today 7 'day)]
	 ["Set in 2 Weeks" (org-mouse-timestamp-today 14 'day)]
	 ["Set in a Month" (org-mouse-timestamp-today 1 'month)]
	 "--"
	 ["+ 1 Day" (org-timestamp-change 1 'day)]
	 ["+ 1 Week" (org-timestamp-change 7 'day)]
	 ["+ 1 Month" (org-timestamp-change 1 'month)]
	 "--"
	 ["- 1 Day" (org-timestamp-change -1 'day)]
	 ["- 1 Week" (org-timestamp-change -7 'day)]
	 ["- 1 Month" (org-timestamp-change -1 'month)])))
     ((funcall get-context :table-special)
      (let ((mdata (match-data)))
	(incf (car mdata) 2)
	(store-match-data mdata))
      (message "match: %S" (match-string 0))
      (popup-menu `(nil ,@(org-mouse-keyword-replace-menu
			   '(" " "!" "^" "_" "$" "#" "*" "'") 0
			   (lambda (mark)
			     (case (string-to-char mark)
			       (?  "( ) Nothing Special")
			       (?! "(!) Column Names")
			       (?^ "(^) Field Names Above")
			       (?_ "(^) Field Names Below")
			       (?$ "($) Formula Parameters")
			       (?# "(#) Recalculation: Auto")
			       (?* "(*) Recalculation: Manual")
			       (?' "(') Recalculation: None"))) t))))
     ((assq :table contextlist)
      (popup-menu
       '(nil
	 ["Align Table" org-ctrl-c-ctrl-c]
	 ["Blank Field" org-table-blank-field]
	 ["Edit Field" org-table-edit-field]
	 "--"
	 ("Column"
	  ["Move Column Left" org-metaleft]
	  ["Move Column Right" org-metaright]
	  ["Delete Column" org-shiftmetaleft]
	  ["Insert Column" org-shiftmetaright]
	  "--"
	  ["Enable Narrowing" (setq org-table-limit-column-width (not org-table-limit-column-width)) :selected org-table-limit-column-width :style toggle])
	 ("Row"
	  ["Move Row Up" org-metaup]
	  ["Move Row Down" org-metadown]
	  ["Delete Row" org-shiftmetaup]
	  ["Insert Row" org-shiftmetadown]
	  ["Sort lines in region" org-table-sort-lines (org-at-table-p)]
	  "--"
	  ["Insert Hline" org-table-insert-hline])
	 ("Rectangle"
	  ["Copy Rectangle" org-copy-special]
	  ["Cut Rectangle" org-cut-special]
	  ["Paste Rectangle" org-paste-special]
	  ["Fill Rectangle" org-table-wrap-region])
	 "--"
	 ["Set Column Formula" org-table-eval-formula]
	 ["Set Field Formula" (org-table-eval-formula '(4))]
	 ["Edit Formulas" org-table-edit-formulas]
	 "--"
	 ["Recalculate Line" org-table-recalculate]
	 ["Recalculate All" (org-table-recalculate '(4))]
	 ["Iterate All" (org-table-recalculate '(16))]
	 "--"
	 ["Toggle Recalculate Mark" org-table-rotate-recalc-marks]
	 ["Sum Column/Rectangle" org-table-sum
	  :active (or (org-at-table-p) (org-region-active-p))]
	 ["Field Info" org-table-field-info]
	 ["Debug Formulas"
	  (setq org-table-formula-debug (not org-table-formula-debug))
	  :style toggle :selected org-table-formula-debug]
	 )))
     ((and (assq :headline contextlist) (not (eolp)))
      (let ((priority (org-mouse-get-priority t)))
	(popup-menu
	 `("Headline Menu"
	   ("Tags and Priorities"
	    ,@(org-mouse-keyword-menu
	       (org-mouse-priority-list)
	       #'(lambda (keyword)
		   (org-mouse-set-priority (string-to-char keyword)))
	       priority "Priority %s")
	    "--"
	    ,@(org-mouse-tag-menu))
	   ("TODO Status"
	    ,@(org-mouse-todo-menu (org-get-todo-state)))
	   ["Show Tags"
	    (with-current-buffer org-mouse-main-buffer (org-agenda-show-tags))
	    :visible (not org-mouse-direct)]
	   ["Show Priority"
	    (with-current-buffer org-mouse-main-buffer (org-agenda-show-priority))
	    :visible (not org-mouse-direct)]
	   ,@(if org-mouse-direct '("--") nil)
	   ["New Heading" org-mouse-insert-heading :visible org-mouse-direct]
	   ["Set Deadline"
	    (progn (org-mouse-end-headline) (insert " ") (org-deadline))
	    :active (not (save-excursion
			   (org-mouse-re-search-line org-deadline-regexp)))]
	   ["Schedule Task"
	    (progn (org-mouse-end-headline) (insert " ") (org-schedule))
	    :active (not (save-excursion
			   (org-mouse-re-search-line org-scheduled-regexp)))]
	   ["Insert Timestamp"
	    (progn (org-mouse-end-headline) (insert " ") (org-time-stamp nil)) t]
					;	 ["Timestamp (inactive)" org-time-stamp-inactive t]
	   "--"
	   ["Archive Subtree" org-archive-subtree]
	   ["Cut Subtree"  org-cut-special]
	   ["Copy Subtree"  org-copy-special]
	   ["Paste Subtree"  org-paste-special :visible org-mouse-direct]
	   ("Sort Children"
	    ["Alphabetically" (org-sort-entries nil ?a)]
	    ["Numerically" (org-sort-entries nil ?n)]
	    ["By Time/Date" (org-sort-entries nil ?t)]
	    "--"
	    ["Reverse Alphabetically" (org-sort-entries nil ?A)]
	    ["Reverse Numerically" (org-sort-entries nil ?N)]
	    ["Reverse By Time/Date" (org-sort-entries nil ?T)])
	   "--"
	   ["Move Trees" org-mouse-move-tree :active nil]
	   ))))
     (t
      (org-mouse-popup-global-menu)))))

(defun org-mouse-mark-active ()
  (and mark-active transient-mark-mode))

(defun org-mouse-in-region-p (pos)
  (and (org-mouse-mark-active)
       (>= pos (region-beginning))
       (<  pos (region-end))))

(defun org-mouse-down-mouse (event)
  (interactive "e")
  (setq this-command last-command)
  (unless (and (= 1 (event-click-count event))
	       (org-mouse-in-region-p (posn-point (event-start event))))
    (mouse-drag-region event)))

(add-hook 'org-mode-hook
	  #'(lambda ()
	      (setq org-mouse-context-menu-function 'org-mouse-context-menu)

	      (when (memq 'context-menu org-mouse-features)
		(org-defkey org-mouse-map [mouse-3] nil)
		(org-defkey org-mode-map [mouse-3] 'org-mouse-show-context-menu))
	      (org-defkey org-mode-map [down-mouse-1] 'org-mouse-down-mouse)
	      (when (memq 'context-menu org-mouse-features)
		(org-defkey org-mouse-map [C-drag-mouse-1] 'org-mouse-move-tree)
		(org-defkey org-mouse-map [C-down-mouse-1] 'org-mouse-move-tree-start))
	      (when (memq 'yank-link org-mouse-features)
		(org-defkey org-mode-map [S-mouse-2] 'org-mouse-yank-link)
		(org-defkey org-mode-map [drag-mouse-3] 'org-mouse-yank-link))
	      (when (memq 'move-tree org-mouse-features)
		(org-defkey org-mouse-map [drag-mouse-3] 'org-mouse-move-tree)
		(org-defkey org-mouse-map [down-mouse-3] 'org-mouse-move-tree-start))

	      (when (memq 'activate-stars org-mouse-features)
		(font-lock-add-keywords
		 nil
		 `((,org-outline-regexp
		    0 `(face org-link mouse-face highlight keymap ,org-mouse-map)
		    'prepend))
		 t))

	      (when (memq 'activate-bullets org-mouse-features)
		(font-lock-add-keywords
		 nil
		 `(("^[ \t]*\\([-+*]\\|[0-9]+[.)]\\) +"
		    (1 `(face org-link keymap ,org-mouse-map mouse-face highlight)
		       'prepend)))
		 t))

	      (when (memq 'activate-checkboxes org-mouse-features)
		(font-lock-add-keywords
		 nil
		 `(("^[ \t]*\\([-+*]\\|[0-9]+[.)]\\) +\\(\\[[ X]\\]\\)"
		    (2 `(face bold keymap ,org-mouse-map mouse-face highlight) t)))
		 t))

	      (defadvice org-open-at-point (around org-mouse-open-at-point activate)
		(let ((context (org-context)))
		  (cond
		   ((assq :headline-stars context) (org-cycle))
		   ((assq :checkbox context) (org-toggle-checkbox))
		   ((assq :item-bullet context)
		    (let ((org-cycle-include-plain-lists t)) (org-cycle)))
		   ((org-footnote-at-reference-p) nil)
		   (t ad-do-it))))))

(defun org-mouse-move-tree-start (event)
  (interactive "e")
  (message "Same line: promote/demote, (***):move before, (text): make a child"))


(defun org-mouse-make-marker (position)
  (with-current-buffer (window-buffer (posn-window position))
    (copy-marker (posn-point position))))

(defun org-mouse-move-tree (event)
  ;; todo: handle movements between different buffers
  (interactive "e")
  (save-excursion
    (let* ((start (org-mouse-make-marker (event-start event)))
	   (end (org-mouse-make-marker (event-end event)))
	   (sbuf (marker-buffer start))
	   (ebuf (marker-buffer end)))

      (when (and sbuf ebuf)
	(set-buffer sbuf)
	(goto-char start)
	(org-back-to-heading)
	(if (and (eq sbuf ebuf)
		 (equal
		  (point)
		  (save-excursion (goto-char end) (org-back-to-heading) (point))))
	    ;; if the same line then promote/demote
	    (if (>= end start) (org-demote-subtree) (org-promote-subtree))
	  ;; if different lines then move
	  (org-cut-subtree)

	  (set-buffer ebuf)
	  (goto-char end)
	  (org-back-to-heading)
	  (when  (and (eq sbuf ebuf)
		      (equal
		       (point)
		       (save-excursion (goto-char start)
				       (org-back-to-heading) (point))))
	    (progn (org-end-of-subtree nil t)
		   (unless (eobp) (backward-char)))
	    (end-of-line)
	    (if (eobp) (newline) (forward-char)))

	  (when (looking-at org-outline-regexp)
	    (let ((level (- (match-end 0) (match-beginning 0))))
	      (when (> end (match-end 0))
		(progn (org-end-of-subtree nil t)
		       (unless (eobp) (backward-char)))
		(end-of-line)
		(if (eobp) (newline) (forward-char))
		(setq level (1+ level)))
	      (org-paste-subtree level)
	      (save-excursion
		(progn (org-end-of-subtree nil t)
		       (unless (eobp) (backward-char)))
		(when (bolp) (delete-char -1))))))))))


(defun org-mouse-transform-to-outline ()
  (interactive)
  (org-back-to-heading)
  (let ((minlevel 1000)
	(replace-text (concat (match-string 0) "* ")))
    (beginning-of-line 2)
    (save-excursion
      (while (not (or (eobp) (looking-at org-outline-regexp)))
	(when (looking-at org-mouse-plain-list-regexp)
	  (setq minlevel (min minlevel (- (match-end 1) (match-beginning 1)))))
	(forward-line)))
    (while (not (or (eobp) (looking-at org-outline-regexp)))
      (when (and (looking-at org-mouse-plain-list-regexp)
		 (eq minlevel (- (match-end 1) (match-beginning 1))))
	(replace-match replace-text))
      (forward-line))))

(defvar org-mouse-cmd) ;dynamically scoped from `org-with-remote-undo'.

(defun org-mouse-do-remotely (command)
					;  (org-agenda-check-no-diary)
  (when (get-text-property (point) 'org-marker)
    (let* ((anticol (- (point-at-eol) (point)))
	   (marker (get-text-property (point) 'org-marker))
	   (buffer (marker-buffer marker))
	   (pos (marker-position marker))
	   (hdmarker (get-text-property (point) 'org-hd-marker))
	   (buffer-read-only nil)
	   (newhead "--- removed ---")
	   (org-mouse-direct nil)
	   (org-mouse-main-buffer (current-buffer)))
      (when (eq (with-current-buffer buffer major-mode) 'org-mode)
	(let ((endmarker (with-current-buffer buffer
			   (org-end-of-subtree nil t)
			   (unless (eobp) (forward-char 1))
			   (point-marker))))
	  (org-with-remote-undo buffer
	    (with-current-buffer buffer
	      (widen)
	      (goto-char pos)
	      (org-show-hidden-entry)
	      (save-excursion
		(and (outline-next-heading)
		     (org-flag-heading nil)))   ; show the next heading
	      (org-back-to-heading)
	      (setq marker (point-marker))
	      (goto-char (max (point-at-bol) (- (point-at-eol) anticol)))
	      (funcall command)
	      (message "_cmd: %S" org-mouse-cmd)
	      (message "this-command: %S" this-command)
	      (unless (eq (marker-position marker) (marker-position endmarker))
		(setq newhead (org-get-heading))))

	    (beginning-of-line 1)
	    (save-excursion
	      (org-agenda-change-all-lines newhead hdmarker 'fixface))))
	t))))

(defun org-mouse-agenda-context-menu (&optional event)
  (or (org-mouse-do-remotely 'org-mouse-context-menu)
      (popup-menu
       '("Agenda"
	 ("Agenda Files")
	 "--"
	 ["Undo" (progn (message "last command: %S" last-command) (setq this-command 'org-agenda-undo) (org-agenda-undo))
	  :visible (if (eq last-command 'org-agenda-undo)
		       org-agenda-pending-undo-list
		     org-agenda-undo-list)]
	 ["Rebuild Buffer" org-agenda-redo t]
	 ["New Diary Entry"
	  org-agenda-diary-entry (org-agenda-check-type nil 'agenda 'timeline) t]
	 "--"
	 ["Goto Today" org-agenda-goto-today
	  (org-agenda-check-type nil 'agenda 'timeline) t]
	 ["Display Calendar" org-agenda-goto-calendar
	  (org-agenda-check-type nil 'agenda 'timeline) t]
	 ("Calendar Commands"
	  ["Phases of the Moon" org-agenda-phases-of-moon
	   (org-agenda-check-type nil 'agenda 'timeline)]
	  ["Sunrise/Sunset" org-agenda-sunrise-sunset
	   (org-agenda-check-type nil 'agenda 'timeline)]
	  ["Holidays" org-agenda-holidays
	   (org-agenda-check-type nil 'agenda 'timeline)]
	  ["Convert" org-agenda-convert-date
	   (org-agenda-check-type nil 'agenda 'timeline)]
	  "--"
	  ["Create iCalendar file" org-icalendar-combine-agenda-files t])
	 "--"
	 ["Day View" org-agenda-day-view
	  :active (org-agenda-check-type nil 'agenda)
	  :style radio :selected (eq org-agenda-current-span 'day)]
	 ["Week View" org-agenda-week-view
	  :active (org-agenda-check-type nil 'agenda)
	  :style radio :selected (eq org-agenda-current-span 'week)]
	 "--"
	 ["Show Logbook entries" org-agenda-log-mode
	  :style toggle :selected org-agenda-show-log
	  :active (org-agenda-check-type nil 'agenda 'timeline)]
	 ["Include Diary" org-agenda-toggle-diary
	  :style toggle :selected org-agenda-include-diary
	  :active (org-agenda-check-type nil 'agenda)]
	 ["Use Time Grid" org-agenda-toggle-time-grid
	  :style toggle :selected org-agenda-use-time-grid
	  :active (org-agenda-check-type nil 'agenda)]
	 ["Follow Mode" org-agenda-follow-mode
	  :style toggle :selected org-agenda-follow-mode]
	 "--"
	 ["Quit" org-agenda-quit t]
	 ["Exit and Release Buffers" org-agenda-exit t]
	 ))))

(defun org-mouse-get-gesture (event)
  (let ((startxy (posn-x-y (event-start event)))
	(endxy (posn-x-y (event-end event))))
    (if (< (car startxy) (car endxy)) :right :left)))


					; (setq org-agenda-mode-hook nil)
(defvar org-agenda-mode-map)
(add-hook 'org-agenda-mode-hook
	  #'(lambda ()
	      (setq org-mouse-context-menu-function 'org-mouse-agenda-context-menu)
	      (org-defkey org-agenda-mode-map [mouse-3] 'org-mouse-show-context-menu)
	      (org-defkey org-agenda-mode-map [down-mouse-3] 'org-mouse-move-tree-start)
	      (org-defkey org-agenda-mode-map [C-mouse-4] 'org-agenda-earlier)
	      (org-defkey org-agenda-mode-map [C-mouse-5] 'org-agenda-later)
	      (org-defkey org-agenda-mode-map [drag-mouse-3]
			  #'(lambda (event) (interactive "e")
			      (case (org-mouse-get-gesture event)
				(:left (org-agenda-earlier 1))
				(:right (org-agenda-later 1)))))))

(provide 'org-mouse)

;;; org-mouse.el ends here
 
   #+END_SRC
** Org old config
 Old good configs for org

#+BEGIN_SRC emacs-lisp
;;======================================================================
;; ORG-MODE

(add-hook 'org-mode-hook 'turn-on-auto-fill)
;; (add-to-list 'load-path "/usr/share/emacs/25.0.50/lisp/")
(require 'org-mouse)

;; TODO: org -mode image zoom
;; (setq org-image-actual-width 800)

(add-hook 'org-mode-hook
          '(lambda ()
             (setq org-file-apps
                   '((auto-mode . emacs)
                     ("\\.jpg\\'" . "feh %s")
                     ("\\.png\\'" . "feh %s")
                     ("\\.mkv\\'" . "mplayer %s")
                     ("\\.mp4\\'" . "mplayer %s")
		     ("\\.avi\\'" . "Mplayer %s")
                     ("\\.pdf\\'" . "evince %s")))))

;; removing the C-j bind for goto-last-change, of el-get
(add-hook 'org-mode-hook
          '(lambda ()
             (define-key org-mode-map (kbd "C-j") nil)))

;;----------------------------------------------------------------------
;; Sort list by checkbox type
;; http://orgmode.org/worg/org-hacks.html

(defun org-sort-list-by-checkbox-type ()
  "Sort list items according to Checkbox state."
  (interactive)
  (org-sort-list
   nil ?f
   (lambda ()
     (if (looking-at org-list-full-item-re)
         (cdr (assoc (match-string 3)
                     '(("[X]" . 1) ("[-]" . 2) ("[ ]" . 3) (nil . 4))))
       4))))

;;----------------------------------------------------------------------
;; org put checkbox if previous is checkbox

(defun org-i-need-checkbox ()
  (interactive)
  (previous-line)
  (setq previous_line
        (buffer-substring
         (line-beginning-position) (line-end-position)))
  (next-line)
  (when (string-match "- \\[" previous_line)
    (insert "[ ] "))
  (insert "haoeush")
  )

;; (add-hook 'org-meta-return 'org-i-need-checkbox)


;;----------------------------------------------------------------------
;; Add dot after headline
;; https://yoo2080.wordpress.com/2013/08/24/changing-the-number-format-for-section-headings-in-org-mode-html-export/
(defun my-html-filter-headline-yesdot (text backend info)
  "Ensure dots in headlines."
  (when (org-export-derived-backend-p backend 'html)
    (save-match-data
      (when (let ((case-fold-search t))
              (string-match (rx (group "<span class=\"section-number-" (+ (char digit)) "\">"
                                       (+ (char digit ".")))
                                (group "</span>"))
                            text))
        (replace-match "\\1.\\2"
                       t nil text)))))

(eval-after-load 'ox
  '(progn
     (add-to-list 'org-export-filter-headline-functions
                  'my-html-filter-headline-yesdot)))

;; (add-to-list 'load-path "~/.emacs.d/el-get/00testing/org-mode/contrib/lisp")
;; (load-file "~/.emacs.d/00testing/org-mode/contrib/lisp/org-export.el")
;; (load-file "/home/rho/.emacs.d/00testing/org-mode/contrib/lisp/org-export-generic.el")
;; (load-file "~/.emacs.d/00testing/org-mode/contrib/lisp/org-e-man.el")
;; (org-install)
;; (require 'org-export)
;; (require 'org-e-man)

;; org-capture
(setq org-capture-templates
      (quote (("t" "todo" entry (file (concat org-directory "/todos.org"))
               "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
              ("n" "note" entry (file (concat org-directory "/notes.org"))
               "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
              ("j" "Journal"
	       entry (file (get-journal-file-today))
	       "* Event: %?\n\n  %i\n\n  From: %a"
	       :empty-lines 1)
              ("y" "youtube-me" entry (file (concat org-directory "/youtube-dl.org"))  "* %?")
              ("o" "CloudFactory" entry (file+datetree (concat org-directory "/cloudfactory.org"))
               "* %?\n%U\n" :clock-in t :clock-resume t)
              ("d" "CloudFactory Docs " entry (file (concat org-directory "/cloudfactory-docs.org"))
               "* %?")
              ("p" "Hisab Kitab " entry (file+datetree+prompt (concat org-directory "/hisab-kitab.org"))
              ("x" "What on my plate today ?? " entry (file+datetree+prompt (concat org-directory "/devops.org"))
               "* %?")
              ("g" "awesome tools " entry (file (concat org-directory "/awesome_tools.org"))
               "* %?")
              ("c" "Coursera Download List" entry (file (concat org-directory "/coursera-dl.org"))
               "* [ ]  %?")
              )))

;; org-caputre goodies
;; http://www.howardism.org/Technical/Emacs/journaling-org.html
(defun get-journal-file-today ()
  "Return filename for today's journal entry."
  (let ((daily-name (format-time-string "%Y%m%d")))
    (expand-file-name (concat org-journal-dir daily-name))))

(defun journal-file-today ()
  "Create and load a journal file based on today's date."
  (interactive)
  (find-file (get-journal-file-today)))

(global-set-key (kbd "C-c f j") 'journal-file-today)


(defun journal-file-insert ()
  "Insert's the journal heading based on the file's name."
  (interactive)
  (when (string-match "\\(20[0-9][0-9]\\)\\([0-9][0-9]\\)\\([0-9][0-9]\\)"
                      (buffer-name))
    (let ((year  (string-to-number (match-string 1 (buffer-name))))
          (month (string-to-number (match-string 2 (buffer-name))))
          (day   (string-to-number (match-string 3 (buffer-name))))
          (datim nil))
      (setq datim (encode-time 0 0 0 day month year))
      (insert (format-time-string
               "#+TITLE: Journal Entry- %Y-%b-%d (%A)\n\n" datim)))))


                                        ; Setting Colours (faces) for todo states to give clearer view of work 
(setq org-todo-keyword-faces
      '(("TODO" . org-warning)
        ("DOING" . "yellow")
        ("BLOCKED" . "red")
        ("REVIEW" . "orange")
        ("DONE" . "green")
        ("ARCHIVED" .  "blue")
        ("FUTURE" .  "#EE82EE")))


#+END_SRC
* Tramp

 #+begin_src emacs-lisp :tangle no
 (use-package tramp)
 #+end_src

* Shell

 #+begin_src emacs-lisp
 (bind-key "C-x m" 'shell)
 (bind-key "C-x M" 'ansi-term)
 #+end_src

* Window

 Convenient keybindings to resize windows.

 #+begin_src emacs-lisp
 (bind-key "s-C-<left>"  'shrink-window-horizontally)
 (bind-key "s-C-<right>" 'enlarge-window-horizontally)
 (bind-key "s-C-<down>"  'shrink-window)
 (bind-key "s-C-<up>"    'enlarge-window)
 #+end_src

 Whenever I split windows, I usually do so and also switch to the other
 window as well, so might as well rebind the splitting key bindings to
 do just that to reduce the repetition.

 #+begin_src emacs-lisp
 (defun vsplit-other-window ()
   "Splits the window vertically and switches to that window."
   (interactive)
   (split-window-vertically)
   (other-window 1 nil))
 (defun hsplit-other-window ()
   "Splits the window horizontally and switches to that window."
   (interactive)
   (split-window-horizontally)
   (other-window 1 nil))

 (bind-key "C-x 2" 'vsplit-other-window)
 (bind-key "C-x 3" 'hsplit-other-window)
 #+end_src

** Winner mode

 Winner mode allows you to undo/redo changes to window changes in Emacs
 and allows you.

 #+begin_src emacs-lisp
 (winner-mode t)
 #+end_src

** Transpose frame

 #+begin_src emacs-lisp
 (use-package transpose-frame
   :ensure t
   :bind ("s-M-t" . transpose-frame))
 #+end_src

* Ido

 #+begin_src emacs-lisp
 (use-package ido
   :init
   (progn
     (setq ido-enable-flex-matching t)
     (setq ido-everywhere t)
     (ido-mode t)
     ;; (use-package ido-ubiquitous
     ;;   :ensure t
     ;;   :init (ido-ubiquitous-mode))
     (use-package ido-vertical-mode
       :ensure t
       :init (ido-vertical-mode 1)
       (setq ido-vertical-define-keys 'C-n-and-C-p-only))))
       #+end_src
       
* Whitespace mode

 #+begin_src emacs-lisp
 (use-package whitespace
   :bind ("s-<f10>" . whitespace-mode))
 #+end_src

* Locate

 Using OS X Spotlight within Emacs by modifying the ~locate~ function.

 I usually use [[*Helm][~helm-locate~]], which does live updates the spotlight
 search list as you type a query.

 #+begin_src emacs-lisp
 ;; mdfind is the command line interface to Spotlight
 (setq locate-command "mdfind")
 #+end_src

* Emacs Setting
  Tired of rebooting the emacs. Closing and opening as ~emacs --debug-init /home/ceasors/.emacs.d/config.org -fs~.
  I have a solution
#+BEGIN_SRC emacs-lisp
(defun restart-emacs ()
  (interactive)
   (load-file "~/.emacs.d/init.el"))
(bind-key "s-<f5>" 'restart-emacs)

#+END_SRC
  
* ELPA packages

  These are the packages that are not built into Emacs.

** Ace Jump Mode

 A quick way to jump around text in buffers.

 [[http://emacsrocks.com/e10.html][See Emacs Rocks Episode 10 for a screencast.]]
 #+begin_src emacs-lisp
 (use-package ace-jump-mode
   :ensure t
   :diminish ace-jump-mode
   :commands ace-jump-mode
   :bind ("C-S-s" . ace-jump-mode))
 #+end_src

** Ace Window

 [[https://github.com/abo-abo/ace-window][ace-window]] is a package that uses the same idea from ace-jump-mode for
 buffer navigation, but applies it to windows. The default keys are
 1-9, but it's faster to access the keys on the home row, so that's
 what I have them set to (with respect to Dvorak, of course).

 #+begin_src emacs-lisp
 (use-package ace-window
   :ensure t
   :config
   (setq aw-keys '(?a ?s ?d ?f ?j ?k ?k ?l))
   (ace-window-display-mode)
   :bind ("s-o" . ace-window))
 #+end_src

** C-Eldoc
    :PROPERTIES:
    :GitHub:   https://github.com/mooz/c-eldoc
    :END:

 This package displays function signatures in the mode line.

 #+begin_src emacs-lisp
 (use-package c-eldoc
   :commands c-turn-on-eldoc-mode
   :ensure t
   :init (add-hook 'c-mode-hook #'c-turn-on-eldoc-mode))
 #+end_src

** Helm
   Mother of changes. Need to learn to configure it better :D
 #+begin_src emacs-lisp
(use-package helm
  :ensure t
  :diminish helm-mode
  :init (progn
          (require 'helm-config)
          (use-package helm-projectile
            :ensure t
            :commands helm-projectile
            :bind ("C-c p h" . helm-projectile))
          (use-package helm-ag :ensure t)
          (setq helm-locate-command "mdfind -interpret -name %s %s"
                helm-ff-newfile-prompt-p nil
                helm-M-x-fuzzy-match t)
          (helm-mode))
  :bind (("C-c h" . helm-command-prefix)
         ("C-x b" . helm-mini)
         ("C-`" . helm-resume)
         ("M-x" . helm-M-x)
         ("C-x C-f" . helm-find-files))) 
 #+end_src

** Magit
 I <3 magit.
 A great interface for git projects. It's much more pleasant to use
 than the git interface on the command line. Use an easy keybinding to
 access magit.

 #+begin_src emacs-lisp
(use-package magit
  :ensure t
  :bind ("C-c m" . magit-status)
  :config
  (define-key magit-status-mode-map (kbd "q") 'magit-quit-session))
 #+end_src

*** Fullscreen magit

 #+BEGIN_QUOTE
 The following code makes magit-status run alone in the frame, and then
 restores the old window configuration when you quit out of magit.

 No more juggling windows after commiting. It's magit bliss.
 #+END_QUOTE
 [[http://whattheemacsd.com/setup-magit.el-01.html][Source: Magnar Sveen]]

 #+begin_src emacs-lisp
 ;;full screen magit-status
 (defadvice magit-status (around magit-fullscreen activate)
   (window-configuration-to-register :magit-fullscreen)
   ad-do-it
   (delete-other-windows))

 (defun magit-quit-session ()
   "Restores the previous window configuration and kills the magit buffer"
   (interactive)
   (kill-buffer)
   (jump-to-register :magit-fullscreen))
 #+end_src

** Edit With Emacs

 Editing input boxes from Chrome with Emacs. Pretty useful to keep all
 significant text-writing on the web within emacs. I typically use this
 with posts on Discourse, which has a post editor that overrides normal
 Emacs key bindings with other functions. As such, ~markdown-mode~ is
 used.

 #+begin_src emacs-lisp
;; (use-package edit-server
;;   :ensure t
;;   :config
;;   (edit-server-start)
;;   (setq edit-server-default-major-mode 'markdown-mode)
;;   (setq edit-server-new-frame nil))
 #+end_src

** Gists

 #+BEGIN_SRC emacs-lisp
(use-package gist
  :ensure t
  :commands gist-list)
 #+END_SRC

;; ** Macrostep

;; Macrostep allows you to see what Elisp macros expand to. Learned about
;; it from the [[https://www.youtube.com/watch?v%3D2TSKxxYEbII][package highlight talk for use-package]].

;; #+begin_src emacs-lisp
;; (use-package macrostep
;;   :ensure t
;;   :bind ("H-`" . macrostep-expand))
;; #+end_src

;; ** Markdown mode

;; #+begin_src emacs-lisp
;; (use-package markdown-mode
;;   :ensure t
;;   :mode (("\\.markdown\\'" . markdown-mode)
;;          ("\\.md\\'"       . markdown-mode)))
;; #+end_src

;; ** Multiple cursors

;; We'll also need to ~(require 'multiple-cusors)~ because of [[https://github.com/magnars/multiple-cursors.el/issues/105][an autoload issue]].

;; #+begin_src emacs-lisp
;; (use-package multiple-cursors
;;   :ensure t
;;   :init (require 'multiple-cursors)
;;   :bind (("C-S-c C-S-c" . mc/edit-lines)
;;          ("C->"         . mc/mark-next-like-this)
;;          ("C-<"         . mc/mark-previous-like-this)
;;          ("C-c C-<"     . mc/mark-all-like-this)
;;          ("C-!"         . mc/mark-next-symbol-like-this)
;;          ("s-d"         . mc/mark-all-dwim)))
;; #+end_src

;; ** Olivetti

;; #+begin_src emacs-lisp
;; (use-package olivetti
;;   :ensure t
;;   :bind ("s-<f6>" . olivetti-mode))
;; #+end_src

;; ** Perspective

;; Workspaces in Emacs.

;; #+begin_src emacs-lisp :tangle no
;; (use-package perspective
;;   :ensure t
;;   :config (persp-mode))
;; #+end_src

** [[https://github.com/skeeto/elfeed][Elfeed]]
   
#+begin_src emacs-lisp
(use-package elfeed
  :ensure t
  :bind ("C-c x" . magit-status)
  :config (setq elfeed-feeds
                '("https://news.ycombinator.com/rss"
                  "http://www.howardism.org/index.xml")))
#+end_src

** Yaml mode
  Ansible plays are written in yaml :D
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t)
#+END_SRC

** Projectile

 #+BEGIN_QUOTE
 Project navigation and management library for Emacs.
 #+END_QUOTE
 http://batsov.com/projectile/


#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :commands projectile-mode
  :config
  (progn
    (projectile-global-mode t)
    (setq projectile-enable-caching t)
    (use-package ag
      :commands ag
      :ensure t)))
#+end_src

** Yasnippet

 Yeah, snippets! I start with snippets from [[https://github.com/AndreaCrotti/yasnippet-snippets][Andrea Crotti's collection]]
 and have also modified them and added my own.

 It takes a few seconds to load and I don't need them immediately when
 Emacs starts up, so we can defer loading yasnippet until there's some
 idle time.

 #+begin_src emacs-lisp
(use-package yasnippet
 :ensure t
 :diminish yas-minor-mode
 :config
 (setq yas-snippet-dirs (concat user-emacs-directory "snippets"))
 (yas-global-mode))
 #+end_src

** Which Key mode
   Emacs package that displays available keybindings in popup 
   #+BEGIN_SRC emacs-lisp
(use-package which-key
 :ensure t
 :init
 :config
  (setq which-key-popup-type 'side-window)
  (which-key-mode))
   #+END_SRC

** Smartparens mode

 #+begin_src emacs-lisp
(use-package smartparens
  :ensure t
  :diminish smartparens-mode
  :config (progn (require 'smartparens-config)
                 (smartparens-global-mode t)))
 #+end_src

*** Smartparens org mode

 Set up some pairings for org mode markup. These pairings won't
 activate by default; they'll only apply for wrapping regions.

 #+begin_src emacs-lisp
(sp-local-pair 'org-mode "~" "~" :actions '(wrap))
(sp-local-pair 'org-mode "/" "/" :actions '(wrap))
(sp-local-pair 'org-mode "*" "*" :actions '(wrap))
 #+end_src
** COMMENT Smartscan

 #+BEGIN_QUOTE
 Quickly jumps between other symbols found at point in Emacs.
 #+END_QUOTE
 http://www.masteringemacs.org/article/smart-scan-jump-symbols-buffer


 #+begin_src emacs-lisp
 (use-package smartscan
   :ensure t
   :config (global-smartscan-mode 1)
   :bind (("s-n" . smartscan-symbol-go-forward)
          ("s-p" . smartscan-symbol-go-backward)))
 #+end_src

;; ** Smex

;; Smex integrates ido with ~M-x~. I used to use this before moving on to
;; [[*Helm][helm]].

;; #+begin_src emacs-lisp
;; (use-package smex
;;   :if (not (featurep 'helm-mode))
;;   :ensure t
;;   :bind ("M-x" . smex))
;; #+end_src

** Skewer mode

 Live coding for HTML/CSS/JavaScript.

 #+begin_src emacs-lisp
 (use-package skewer-mode
  :commands skewer-mode
   :ensure t
   :config (skewer-setup))
 #+end_src

** Smoothscrolling

 This makes it so ~C-n~-ing and ~C-p~-ing won't make the buffer jump
 around so much.

 #+begin_src emacs-lisp
 (use-package smooth-scrolling
   :ensure t)
 #+end_src

** Scratch

 Convenient package to create =*scratch*= buffers that are based on the
 current buffer's major mode. This is more convienent than manually
 creating a buffer to do some scratch work or reusing the initial
 =*scratch*= buffer.

 #+begin_src emacs-lisp
 (use-package scratch
   :ensure t)
 #+end_src

** Zoom-frm

 =zoom-frm= is a nice package that allows you to resize the text of
 entire Emacs frames (this includes text in the buffer, mode line, and
 minibuffer). The =zoom-in/out= command acts similar to the
 =text-scale-adjust= command---you can chain zooming in, out, or
 resetting to the default size once the command has been initially
 called.

 Changing the =frame-zoom-font-difference= essentially enables a
 "presentation mode" when calling =toggle-zoom-frame=.

 #+begin_src emacs-lisp
 (use-package zoom-frm
   :ensure t
   :bind (("C-M-=" . zoom-in/out)
          ("H-z"   . toggle-zoom-frame))
   :config
   (setq frame-zoom-font-difference 10))
 #+end_src
** Undo Tree
   Previously when I had tried [[https://github.com/syl20bnr/spacemacs][spacemacs]] I got fan of this one.
#+BEGIN_SRC emacs-lisp
 (use-package undo-tree
  :ensure t
  :config
  (global-undo-tree-mode))
#+END_SRC



** Markdown Mode
   Big fan of org-mode, but people also love README.md, #worthtrying
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :config
  (autoload 'markdown-mode "markdown-mode"
    "Major mode for editing Markdown files" t)
  (add-to-list 'auto-mode-alist '("\\.text\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

  )
#+END_SRC

** Docker 
   dhayu-dhayoou... dakari sake ta :p
*** Docker File Mode
    Cheese, they have it updated, better write an abreast_of function
 #+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :ensure t
  :config
  (require 'dockerfile-mode)
  (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))
  )
 #+END_SRC

** Coffee mode
   coffee, hubot cha ni, tyo coffee ma cha ke tesko code

 #+BEGIN_SRC emacs-lisp
(use-package coffee-mode
  :ensure t
  :config
  ;; automatically clean up bad whitespace
  (setq whitespace-action '(auto-cleanup))
  ;; only show bad whitespace
  (setq whitespace-style '(trailing space-before-tab indentation empty space-after-tab))
  ;; This gives you a tab of 2 spaces
  (custom-set-variables '(coffee-tab-width 2))
  )
 #+END_SRC

** Eye Candy Decor
*** Mode Icons
   Show icons instead of mode names in emacs.
#+BEGIN_SRC emacs-lisp
(use-package mode-icons
  :ensure t
  :config
  (mode-icons-mode)
  )

#+END_SRC

#+RESULTS:
: t
*** Tabbar Everything
**** Tabbar Mode
     We love to have tabs to track our track, don't we
#+BEGIN_SRC emacs-lisp
(use-package tabbar
  :ensure t
  :config
  (require 'tabbar)
  (tabbar-mode t)
  )

#+END_SRC
**** Tabbar Ruler
   Everything is copied from [[https://github.com/rhoit/dot-emacs/blob/master/config/tabbar.cfg.el][rhoit dai's config]]
   
#+BEGIN_SRC emacs-lisp
(use-package tabbar-ruler
  :ensure t
  :bind (
         ("<f7>" . tabbar-mode)
         ("C-<next>" . tabbar-forward)
         ("C-S-<iso-lefttab>" . tabbar-backward) 
         ("C-S-<prior>" . tabbar-backward-group)
         ("C-S-<next>" . tabbar-forward-group)
         ("C-<tab>" . tabbar-forward-tab)
         ;; ("C-<prior>" .tabbar-backward)
         )

  :config 
  (setq tabbar-buffer-groups-function
        (lambda ()
          (list (cond
                 ((string-equal "*" (substring (buffer-name) 0 1)) "Emacs Buffer")
                 ((eq major-mode 'dired-mode) "Dired")
                 ((eq major-mode 'compilation-mode) "Compilation")
                 (t "User Buffer")
                 ))))

;; ;; you may redefine these:
(defvar tabbar-key-binding-modifier-list '(meta)
  "List of modifiers to be used for keys bound to tabs.
Must call `tabbar-define-access-keys' or toggle `tabbar-mode' for
changes to this variable to take effect.")

(defvar tabbar-key-binding-keys '((49 kp-1) (50 kp-2) (51 kp-3) (52 kp-4) (53 kp-5) (54 kp-6) (55 kp-7) (56 kp-8) (57 kp-9) (48 kp-0))
  "Codes of ten keys bound to tabs (without modifiers.
This is a list with 10 elements, one for each of the first 10
tabs.  Each element is a list of keys, either of which can be
used in conjunction with the modifiers defined in
`tabbar-key-binding-modifier-list'. Must call
`tabbar-define-access-keys' or toggle `tabbar-mode' for changes
to this variable to take effect.")

(defsubst tabbar-key-command (index)	; command name
  (intern (format "tabbar-select-tab-%s" index)))

(eval-when-compile (require 'cl))
(defun tabbar-define-access-keys (&optional modifiers keys)
  "Set tab access keys for `tabbar-mode'.
MODIFIERS as in `tabbar-key-binding-modifier-list', and
KEYS defines the elements to use for `tabbar-key-binding-keys'."
  (if modifiers (setq tabbar-key-binding-modifier-list modifiers))
  (if keys (setq tabbar-key-binding-keys keys))
  (loop for keys in tabbar-key-binding-keys
	for ni from 1 to 10 do
	(let ((name (tabbar-key-command ni)))
	  (eval `(defun ,name ()
		   "Select tab in selected window."
		   (interactive)
		   (tabbar-select-tab-by-index ,(- ni 1))))
	  ;; store label in property of command name symbol
	  (put name 'label
	       (format "%c" (car keys)))
	  (loop for key in keys do
		(define-key tabbar-mode-map
		  (vector (append
			   tabbar-key-binding-modifier-list
			   (list key)))
		  name)))))

(defun tabbar-select-tab-by-index (index)
  ;; (let ((vis-index (+ index (or (get (tabbar-current-tabset) 'start) 0))))
  (unless (> (length (tabbar-tabs (tabbar-current-tabset))) 1)
    ;; better window (with tabs)in this frame?

    (let ((better-w))
      (walk-windows (lambda (w)
		      (and (not better-w)
			   (with-selected-window w
			     (if (> (length (tabbar-tabs (tabbar-current-tabset t))) 1)
				 (setq better-w w)))))
		    'avoid-minibuf (selected-frame))
      (if better-w (select-window better-w))))

  (tabbar-window-select-a-tab
   (nth index (tabbar-tabs (tabbar-current-tabset)))))

(defun tabbar-window-select-a-tab (tab)
  "Select TAB"
  (let ((one-buffer-one-frame nil)
	(buffer (tabbar-tab-value tab)))
    (when buffer

      (set-window-dedicated-p (selected-window) nil)
      (let ((prevtab (tabbar-get-tab (window-buffer (selected-window))
				     (tabbar-tab-tabset tab)))
	    (marker (cond ((bobp) (point-min-marker))
                          ((eobp) (point-max-marker))
                          (t (point-marker)))))
	(set-marker-insertion-type marker t)
                                        ;	(assq-set prevtab marker 'tab-points)
	)
      (switch-to-buffer buffer)
                                        ;      (let ((new-pt (cdr (assq tab tab-points))))
                                        ;	(and new-pt
                                        ;	     (eq (marker-buffer new-pt) (window-buffer (selected-window)))
                                        ;	     (let ((pos (marker-position new-pt)))
                                        ;	       (unless (eq pos (point))
                                        ;		 (if transient-mark-mode
                                        ;		     (deactivate-mark))
                                        ;		 (goto-char pos))
                                        ;	       (set-marker new-pt nil) ;; delete marker
                                        ;	       )))
      )))
                                        ; (marker-insertion-type (cdr (car tab-points)))

(tabbar-define-access-keys)

;; key binding
;; (global-set-key [(control shift prior)] 'tabbar-backward-group)
;; (global-set-key [(control shift next)] 'tabbar-forward-group)
;; (define-key global-map [(control tab)] 'tabbar-forward)
;; (define-key global-map (kbd "C-<next>") 'tabbar-forward)
;; (define-key global-map (kbd "C-S-<iso-lefttab>") 'tabbar-backward)
;; (define-key global-map (kbd "C-<prior>") 'tabbar-backward)

)
#+END_SRC



** COMMENT Emacs IPython Notebook
 #+begin_src emacs-lisp
 (use-package ein
   :ensure t)
 #+end_src

** COMMENT Expand region

#+begin_src emacs-lisp
 (use-package expand-region
   :ensure t
   :bind ("C-@" . er/expand-region))
#+end_src

** COMMENT Floobits
 Using [[https://floobits.com/][Floobits]] for code collaboration.

 #+begin_src emacs-lisp :tangle no
 (use-package floobits
   :ensure t)
 #+end_src

** COMMENT Flycheck
 Still need to set up hooks so that flycheck automatically runs in
 python mode, etc. js2-mode is already really good for the syntax
 checks, so I probably don't need the jshint checks with flycheck for
 it.

 #+begin_src emacs-lisp
 (use-package flycheck
   :ensure t
   :config (setq flycheck-html-tidy-executable "tidy5"))
 #+end_src

*** COMMENT Linter setups

 Install the HTML5/CSS/JavaScript linters.
 #+begin_src sh
 brew tap homebrew/dupes
 brew install tidy
 npm install -g jshint
 npm install -g csslint
 #+end_src
** COMMENT Python
 Integrates with IPython.

 #+begin_src emacs-lisp :tangle no
 (use-package python-mode
   :ensure t)
 #+end_src

** COMMENT Restclient

 See [[http://emacsrocks.com/e15.html][Emacs Rocks! Episode 15]] to learn how restclient can help out with
 testing APIs from within Emacs. The HTTP calls you make in the buffer
 aren't constrainted within Emacs; there's the
 =restclient-copy-curl-command= to get the equivalent =curl= call
 string to keep things portable.

 #+begin_src emacs-lisp
 (use-package restclient
   :ensure t
   :mode ("\\.restclient\\'" . restclient-mode))
 #+end_src

** COMMENT Visual-regexp

 #+begin_src emacs-lisp
 (use-package visual-regexp
   :ensure t
   :init
   (use-package visual-regexp-steroids :ensure t)
   :bind (("C-c r" . vr/replace)
          ("C-c q" . vr/query-replace)
          ("C-c m" . vr/mc-mark) ; Need multiple cursors
          ("C-M-r" . vr/isearch-backward)
          ("C-M-s" . vr/isearch-forward)))
 #+end_src

** COMMENT Webmode

 #+begin_src emacs-lisp :tangle no
 (use-package web-mode
   :ensure t)
 #+end_src

** COMMENT Emmet

 According to [[http://emmet.io/][their website]], "Emmet  the essential toolkit for web-developers."

 #+begin_src emacs-lisp
 (use-package emmet-mode
   :ensure t
   :commands emmet-mode
   :config
   (add-hook 'html-mode-hook 'emmet-mode)
   (add-hook 'css-mode-hook 'emmet-mode))
 #+end_src

* COMMENT Computer-specific settings
  Load some computer-specific settings, such as the name and and email address. The way the settings are loaded is based off of [[https://github.com/magnars/.emacs.d][Magnar Sveen's] config.

 In my case, the computers I use usually use the same username (my
 name, go figure), so instead of basing the specific settings from the
 username, I use the hostname. The shell command ~hostname -s~ gets the
 hostname for the computer without any "domain information," such as
 the ".local" suffix.

 I use the ~s-trim~ function, which comes from the [[https://github.com/magnars/s.el][s string library]]. I
 ~require~ it here, though a handful of the ELPA packages that are
 loaded earlier in the config depend on it already. That means the
 ~require~ is redundant, but better to be explicit about it.

 #+begin_src emacs-lisp
(defvar mai/user-settings-dir nil
  "The directory with user-specific Emacs settings for this
  user.")

;; Settings for currently logged in user
(require 's)
(setq mai/user-settings-dir
      (concat user-emacs-directory
              "users/"
              (s-trim (shell-command-to-string "hostname -s"))))
(add-to-list 'load-path mai/user-settings-dir)

;; Load settings specific for the current user
(when (file-exists-p mai/user-settings-dir)
  (mapc 'load (directory-files mai/user-settings-dir nil "^[^#].*el$")))
 #+end_src

* COMMENT Languages
** C/Java

 I don't like the default way that Emacs handles indentation. For instance,
 #+begin_src C
 int main(int argc, char *argv[])
 {
   /* What's with the brace alignment? */
   if (check)
     {
     }
   return 0;
 }
 #+end_src
 #+begin_src java
 switch (number)
     {
     case 1:
         doStuff();
         break;
     case 2:
         doStuff();
         break;
     default:
         break;
     }
 #+end_src

 Luckily, I can modify the way Emacs formats code with this configuration.
 #+begin_src emacs-lisp
 (defun my-c-mode-hook ()
   (setq c-basic-offset 4)
   (c-set-offset 'substatement-open 0)   ; Curly braces alignment
   (c-set-offset 'case-label 4))         ; Switch case statements alignment

 (add-hook 'c-mode-hook 'my-c-mode-hook)
 (add-hook 'java-mode-hook 'my-c-mode-hook)
 #+end_src

* Misc
** Display Time

 When displaying the time with =display-time-mode=, I don't care about
 the load average.

 #+begin_src emacs-lisp
(setq display-time-default-load-average nil)
(display-time-mode t)
 #+end_src

** Display Battery Mode

 See the documentation for =battery-mode-line-format= for the format
 characters.

 #+begin_src emacs-lisp
 (setq battery-mode-line-format " %b%p%% ")
 (display-battery-mode t)
 #+end_src

** Better scrolling

 #+begin_src emacs-lisp
 (setq mouse-wheel-scroll-amount (quote (0.01)))
 #+end_src

** COMMENT Docview keybindings

 #+begin_src emacs-lisp
 (use-package doc-view
   :config
   (define-key doc-view-mode-map (kbd "<right>") 'doc-view-next-page)
   (define-key doc-view-mode-map (kbd "<left>") 'doc-view-previous-page))
 #+end_src

** COMMENT Visible mode

 I found out about this mode my looking through simple.el. I use it to
 see raw org-mode files without going to a different mode like
 text-mode, which is what I had done in order to see invisible text
 (with org hyperlinks). The entire buffer contents will be visible
 while still being in org mode.

 #+begin_src emacs-lisp
 (use-package visible-mode
   :bind ("H-v" . visible-mode))
 #+end_src

** COMMENT Shalil mode
   These are goodies from shalil bro
   #+BEGIN_SRC emacs-lisp
   
   #+END_SRC

* Custom function
** Gitwatcher
   track changes and push file changes with git
   #+BEGIN_SRC emacs-lisp
(defvar autocomit-dir-set '()
  "Set of directories for which there is a pending timer job")

(defun autocommit-schedule-commit (dn)
  "Schedule an autocommit (and push) if one is not already scheduled for the given dir."
  (if (null (member dn autocommit-dir-set))
      (progn
        (run-with-idle-timer
         10 nil
         (lambda (dn)
           (setq autocommit-dir-set (remove dn autocommit-dir-set))
           (message (concat "Committing org files in " dn))
           (shell-command (concat "cd " dn " && git commit -m 'Updated org files.'"))
           (shell-command (concat "cd " dn " && git push & /usr/bin/true"))
           (run-hooks 'dustin-autocommit-hooks))
         dn)
        (setq autocommit-dir-set (cons dn autocommit-dir-set)))))

(defun autocommit-after-save-hook ()
  "After-save-hook to 'git add' the modified file and schedule a commit and push in the idle loop."
  (let ((fn (buffer-file-name)))
    (message "git adding %s" fn)
    (shell-command (concat "git add " fn))
    (autocommit-schedule-commit (file-name-directory fn))))

(defun autocommit-setup-save-hook ()
  "Set up the autocommit save hook for the current file."
  (interactive)
  (message "Set up autocommit save hook for this buffer.")
  (add-hook 'after-save-hook 'autocommit-after-save-hook nil t))

;;
;; Integration
;;

(defun dustin-visiting-a-file ()
  (let* ((fn (buffer-file-name))
         (dn (file-name-directory fn)))
    (if (equal dn (expand-file-name "~/org/"))
        (progn
          (message "Setting up local hook for %s (in %s)"
                   (file-name-nondirectory fn) dn)
          (autocommit-setup-save-hook)
          (add-hook 'dustin-autocommit-hooks 'org-mobile-push)))))

(add-hook 'find-file-hook 'dustin-visiting-a-file)

   #+END_SRC

   #+RESULTS:
   | dustin-visiting-a-file | #[0 \302\301!\210\303\304!8\211\207 [buffer-file-name auto-revert-tail-pos make-local-variable 7 file-attributes] 3] | git-commit-setup-check-buffer | projectile-global-mode-check-buffers | global-undo-tree-mode-check-buffers | undo-tree-load-history-hook | smartparens-global-mode-check-buffers | yas-global-mode-check-buffers | recentf-track-opened-file | global-visual-line-mode-check-buffers | global-font-lock-mode-check-buffers | epa-file-find-file-hook | vc-refresh-state |

